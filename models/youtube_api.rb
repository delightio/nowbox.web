module Aji
  class YoutubeAPI
    USER_FEED_URL = "http://gdata.youtube.com/feeds/api/users"

    attr_reader :uid

    def initialize uid=nil, token=nil, secret=nil
      raise ArgumentError, "Invalid credentials" unless
        (token and secret) or not (token or secret)
      @uid, @token, @secret = uid, token, secret
      reset_subscription_ids
      reset_watch_later_entry_ids
    end

    def reset_subscription_ids
      @subscription_ids = {}
    end

    def reset_watch_later_entry_ids
      @watch_later_entry_ids = {}
    end

    def subscription_ids
      subscriptions if @subscription_ids.empty?
      @subscription_ids
    end

    def subscriptions uid=uid
      options = { 'max-results' => 50, 'start-index' => 1 }
      tracker.hit! :get

      [].tap do |subs|
        sub_feed = client.subscriptions(uid, options)

        while sub_feed.length == options['max-results'] do
          sub_feed.each do |sub|
            cid = sub.title.split(" ").last.downcase
            @subscription_ids[cid] = sub.id
            subs.push(
              Account::Youtube.create_or_find_by_lower_uid(cid).to_channel)
          end

          tracker.hit! :get
          options['start-index'] += options['max-results']
          sub_feed = client.subscriptions(uid, options)
        end

        sub_feed.each do |sub|
          cid = sub.title.split(" ").last.downcase
          @subscription_ids[cid] = sub.id
          subs.push(Account::Youtube.create_or_find_by_lower_uid(cid).to_channel)
        end
      end
    end

    def subscribe_to channel_uid
      post_tracker.hit! :post
      post_client.subscribe_channel channel_uid
    rescue UploadError => e
      raise e unless e.message =~ /Subscription already exists/
    end

    def unsubscribe_from channel_uid
      post_tracker.hit! :post
      reset_subscription_ids unless subscription_ids[channel_uid]
      if subscription_ids[channel_uid]
        post_client.unsubscribe_channel subscription_ids[channel_uid]
      end
    rescue UploadError => e
      Aji.log :WARN, "#{e.class}:#{e.message}"
    end

    def favorite_videos uid=uid
      options = { 'max-results' => 50, 'start-index' => 1 }

      [].tap do |favorites|
        tracker.hit! :get
        videos = client.favorites(uid, options).videos
        options['start-index'] += options['max-results']

        while videos.length == options['max-results'] do
          videos.each do |v|
            favorites << youtube_it_to_video(v)
          end

          tracker.hit! :get
          videos = client.favorites(uid, options).videos
          options['start-index'] += options['max-results']
        end

        videos.each do |v|
          favorites << youtube_it_to_video(v)
        end
      end.reject{ |v| v.external_id.nil? }
    end

    def add_to_favorites video_external_id
      post_tracker.hit! :post
      post_client.add_favorite video_external_id
    rescue UploadError => e
      raise e unless e.message =~ /Favorite already exists/
    end

    def remove_from_favorites video_external_id
      post_tracker.hit! :post
      post_client.delete_favorite video_external_id
    rescue UploadError => e
      raise e unless e.message =~ /Video favorite not found/
    end

    def watch_later_entry_ids
      watch_later_videos if @watch_later_entry_ids.empty?
      @watch_later_entry_ids
    end

    def watch_later_videos
      options = { 'max-results' => 50, 'start-index' => 1 }

      [].tap do |watch_later|
        tracker.hit! :get
        youtube_videos = client.watch_later(uid, options).videos
        options['start-index'] += options['max-results']

        while youtube_videos.length == options['max-results'] do
          youtube_videos.each do |v|
            video = youtube_it_to_video(v)
            watch_later << video
            @watch_later_entry_ids[video.external_id] =
              v.video_id.split(':').last
          end

          tracker.hit! :get
          youtube_videos = client.watch_later(uid, options).videos
          options['start-index'] += options['max-results']
        end

        youtube_videos.each do |v|
          video = youtube_it_to_video(v)
          watch_later << video
          @watch_later_entry_ids[video.external_id] =
            v.video_id.split(':').last
        end
      end.reject{ |v| v.external_id.nil? }
    end

    def add_to_watch_later video_external_id
      post_tracker.hit! :post
      post_client.add_watch_later video_external_id
    rescue UploadError => e
      raise e unless e.message =~ /This resource already exists/
    end

    def remove_from_watch_later video_external_id
      post_tracker.hit! :post
      reset_watch_later_entry_ids unless watch_later_entry_ids[video_external_id]
      if watch_later_entry_ids[video_external_id]
        post_client.delete_watch_later watch_later_entry_ids[video_external_id]
      end
    rescue UploadError => e
      raise e unless e.message =~ /Playlist video not found/
    end

    def author_info uid=uid
      tracker.hit! :get
      DataGrabber.new(uid).build_hash
    end

    def valid_uid? uid=uid
      return false unless uid.ascii_only?
      tracker.hit!
      feed_url = "#{USER_FEED_URL}/#{uid}?dev_key=#{Aji.conf['YOUTUBE_KEY_GLOBAL']}"
      Faraday.get(feed_url).status == 200
    end

    def video_info youtube_id
      tracker.hit!
      youtube_it_to_hash client.video_by youtube_id
    rescue OpenURI::HTTPError => exp
      raise VideoAPI::Error, "Unable to populate #{youtube_id}.", exp.backtrace
    rescue NoMethodError => exp
      raise VideoAPI::Error, "Unable to reach YoutubeAPI.", exp.backtrace
    end

    def video youtube_id
      youtube_it_to_video client.video_by youtube_id
    end

    def uploaded_videos uid=uid
      tracker.hit!
      client.videos_by(:author => uid, :order_by => 'published',
                       :per_page => 50).videos.map{ |v| youtube_it_to_video v }
    end

    def keyword_search keywords, per_page=50
      tracker.hit!
      client.videos_by(
        :query => Array(keywords).join(' '),
        :per_page => per_page).
        videos.map{ |v| youtube_it_to_video v }
    end

    def youtube_it_to_hash video
      if youtube_category = video.categories.first
        category = Category.find_or_create_by_raw_title youtube_category.label,
          :title => youtube_category.term
      else
        category = Category.undefined
      end

      author = Account::Youtube.create_or_find_by_lower_uid video.author.name

      {
        :title => video.title,
        :external_id => Link.new(video.player_url).external_id,
        :description => video.description,
        :duration => video.duration,
        :viewable_mobile => (not video.noembed),
        :view_count => video.view_count,
        :category => category,
        :author => author,
        :published_at => video.published_at,
        :source => :youtube,
        :populated_at => Time.now
      }
    end

    def youtube_it_to_video video
      h = youtube_it_to_hash video
      # We indexed by external_id followed by source
      Video.update_or_create_by_external_id_and_source(
        h[:external_id], h[:source], h)
    end

    def tracker
      @tracker ||= if @token and @secret
                     APITracker.new "#{self.class.to_s}:auth", Aji.redis,
                       cooldown: 2.minutes, hits_per_session: 1000,
                       method_limits: { post: 0.0 }
                   else
                     APITracker.new "#{self.class.to_s}:global", Aji.redis,
                       cooldown: 1.hour, hits_per_session: 1000000
                   end
    end

    def post_tracker
      @post_tracker ||= APITracker.new "#{self.class.to_s}:auth_post",
        Aji.redis, cooldown: 20.minutes, hits_per_session: 500,
    end

    def uid_from_channel channel
      channel.accounts.first.uid
    end

    def client
      @client ||=
        if @token and @secret
          YouTubeIt::OAuthClient.new(consumer_key: Aji.conf['YOUTUBE_OA_KEY'],
                                     consumer_secret: Aji.conf['YOUTUBE_OA_SECRET'], username: @uid,
                                     dev_key: Aji.conf['YOUTUBE_KEY_AUTH']).tap do |c|
                                       c.authorize_from_access @token, @secret
                                     end
        else
          @@client ||= YouTubeIt::Client.new dev_key: Aji.conf['YOUTUBE_KEY_GLOBAL']
        end
    end
    private :client, :reset_subscription_ids, :reset_watch_later_entry_ids

    def post_client
      raise "Cannot create post client without token and secret" unless
        @token and @secret

      @post_client ||= YouTubeIt::OAuthClient.new(
        consumer_key: Aji.conf['YOUTUBE_OA_KEY'], username: @uid,
        consumer_secret: Aji.conf['YOUTUBE_OA_SECRET'],
        dev_key: Aji.conf['YOUTUBE_KEY_AUTH_POST']).tap do |c|
          c.authorize_from_access @token, @secret
        end
    end

    def self.api
      @singleton ||= new
    end

    def self.global_tracker
      @global_tracker ||= new.tracker
    end

    def self.authed_tracker
      @authed_tracker ||= new("foo","bar","baz").tracker
    end

    class DataGrabber
      def initialize youtube_uid, data=nil
        @youtube_uid = youtube_uid
        @feed_url =
          "http://gdata.youtube.com/feeds/api/users/#{youtube_uid}?alt=json&v=2&dev_key=#{Aji.conf['YOUTUBE_KEY_GLOBAL']}"
        @data = if data then data['entry'] else get_data_from_youtube end
      end

      def uid
        username.downcase
      end

      def published
        time_string = @data.fetch('published', {}).fetch('$t', nil)
        if time_string then DateTime.parse(time_string).to_time else nil end
      end

      def updated
        time_string = @data.fetch('updated', {}).fetch('$t', nil)
        t = if time_string then DateTime.parse(time_string) else nil end
        #t.to_time # Why the shit does this not work?
        return if t.nil?
        t.instance_eval { Time.utc(year, mon, mday, hour, min, sec).getlocal }
      end

      def category
        @data.fetch('category', [nil,{}])[1].fetch('term', '*** undefined ***')
      end

      def title
        @data.fetch('title', {}).fetch('$t', "")
      end

      def about_me
        @data.fetch('yt$aboutMe',{}).fetch('$t', "")
      end

      def profile
        find_link 'alternate'
      end

      def homepage
        find_link 'related'
      end

      def featured_video_id
        link = find_link 'http://gdata.youtube.com/schemas/2007#featured-video'
        match = link.match(Link::YOUTUBE_ID_REGEXP)
        match && match[1] || nil
      end

      def first_name
        @data.fetch('yt$firstName', {}).fetch('$t', "")
      end

      def last_name
        @data.fetch('yt$lastName', {}).fetch('$t', "")
      end

      def hobbies
        @data.fetch('yt$hobbies', {}).fetch('$t', "")
      end

      def location
        @data.fetch('yt$location', {}).fetch('$t', "")
      end

      def occupation
        @data.fetch('yt$occupation', {}).fetch('$t', "")
      end

      def school
        @data.fetch('yt$school', {}).fetch('$t', "")
      end

      def subscriber_count
        @data.fetch('yt$statistics', {}).fetch('subscriberCount', 0).to_i
      end

      def video_upload_count
        link = @data.fetch('gd$feedLink', []).find{ |l| l['rel'] =~ /uploads/ }
        link and link['countHint'] or 0
      end

      def thumbnail
        @data.fetch("media$thumbnail", {}).fetch('url', "")
      end

      def get_data_from_youtube
        response = Faraday.get(@feed_url)
        return {} unless response.status == 200
        MultiJson.decode(response.body)['entry']
      end

      def username
        @data.fetch('yt$username', {}).fetch('$t', "")
      end

      def total_upload_views
        @data.fetch('yt$statistics', {}).fetch('totalUploadViews', 0).to_i
      end

      def find_link link_type
        link = @data.fetch('link', []).find do |link_hash|
          link_hash['rel'] == link_type
        end

        if link then link['href'] else "" end
      end

      def build_hash
        {
          'uid' => uid,
          'published' => published,
          'updated' => updated,
          'category' => category,
          'title' => title,
          'profile' => profile,
          'homepage' => homepage,
          'featured_video_id' => featured_video_id,
          'about_me' => about_me,
          'first_name' => first_name,
          'last_name' => last_name,
          'hobbies' => hobbies,
          'location' => location,
          'occupation' => occupation,
          'school' => school,
          'subscriber_count' => subscriber_count,
          'video_upload_count' => video_upload_count,
          'thumbnail' => thumbnail,
          'username' => username,
          'total_upload_views' => total_upload_views
        }
      end
    end
  end
end

